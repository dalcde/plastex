
\section{\module{plasTeX.ConfigManager} --- \plasTeX\ Configuration}
\label{sec:configuration-api}

\declaremodule{standard}{plasTeX.ConfigManager}
\modulesynopsis{\plasTeX's configuration management system}

The configuration system in \plasTeX\ that parses the command-line options
and configuration files is very flexible.  While many options are setup
by the \plasTeX\ framework, it is possible for you to add your own options.
This is useful if you have macros that may need to be configured by 
configurable options, or if you write a renderer that surfaces special options
to control it.

The config files that \class{ConfigManager} supports are standard INI-style
files.  This is the same format supported by Python's \class{ConfigParser}.
However, this API has been extended with some dictionary-like behaviors
to make it more Python friendly.

In addition to the config files, \class{ConfigManager} can also parse
command-line options and merge the options from the command-line into
the options set by the given config files.  In fact, when adding options
to a \class{ConfigManager}, you specify both how they appear in the config
file as well as how they appear on the command-line.  Below is a basic 
example.

\begin{verbatim}
from plasTeX.ConfigManager import *
from argparse import ArgumentParser
c = ConfigManager()

# Create a new section in the config file.  This corresponds to the
# [ sectionname ] sections in an INI file.  The returned value is 
# a reference to the new section
d = c.add_section('debugging')

# Add an option to the 'debugging' section called 'verbose'.
# This corresponds to the config file setting:
#
# [debugging]
# verbose = no
#
d['verbose'] = BooleanOption(
    """ Increase level of debugging information """,
    options = '-v --verbose !-q !--quiet',
    default = False,
)

# Read config files
c.loadFromFiles(['/etc/myconfig.ini', '~/myconfig.ini')

# Construct an ArgumentParser and add config options to the parser
parser = ArgumentParser("plasTeX")
c.registerArgparse(parser)

# Parse commands and input into config.
data = vars(parser.parse_args())
c.updateFromDict(data)

# Print the value of the 'verbose' option in the 'debugging' section
print(c['debugging']['verbose'])
\end{verbatim}

One interesting thing to note about retrieving values from a 
\class{ConfigManager} is that you get the value of the option
rather than the option instance that you put in.  For example, in the
code above.  A \class{BooleanOption} in put into the `verbose' option
slot, but when it is retrieved in the \function{print} statement at
the end, it prints out a boolean value.  This is true of all option
types.  You can access the option instance in the \member{data} attribute
of the section (e.g. \code{c['debugging'].data['verbose']}).


\subsection{ConfigManager Objects}

\begin{classdesc}{ConfigManager}{}
Instantiate a configuration class for \plasTeX\ that parses the command-line options
as well as reads the config files. The class inherits \class{dict}, and the
underlying \class{dict} is the dict of sections.
\end{classdesc}

\begin{methoddesc}[ConfigManager]{addSection}{name, description=None}
create a new section in the configuration with the given name.  This 
name is the name used for the section heading in the INI file (i.e. the
name used within square brackets (\lbrack~\rbrack) to start a section). The
description is the section header that shows up in the command line interface.
This defaults to \code{name.capitalize() + " Options"}.

The return value of this method is a reference to the newly created section.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{read}{filenames}
read configuration data contained in files specified by \var{filenames}.
Files that cannot be opened are silently ignored.  This is designed so that
you can specify a list of potential configuration file locations (e.g.
current directory, user's home directory, system directory), and all 
existing configuration files in the list will be read.  A single filename
may also be given.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{registerArgparse}{parser}
adds the command line options specified by the config to the parser.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{updateFromDict}{data}
  updates the configuration based on the data in \var{data}. The format of
  \var{data} is defined to be what is returned by
  \code{vars(parser.parse_args())}, where \var{parser} is populated by
  \method{registerArgparse}. This is intended to be used in conjuction with
  \method{registerArgparse}.
\end{methoddesc}

\subsection{ConfigSection Objects}

\begin{classdesc}{ConfigSection}{name, parent}
Instantiate a \class{ConfigSection} object.

\var{name} is the name of the section.

\var{parent} is the \class{ConfigManager} that contains this section.
\end{classdesc}

\begin{memberdesc}[ConfigSection]{data}
dictionary that contains the option instances.  This is only accessed
if you want to retrieve the real option instances.  Normally, you would
use standard dictionary key access syntax on the section itself to
retrieve the option values.
\end{memberdesc}

\begin{memberdesc}[ConfigSection]{name}
the name given to the section.
\end{memberdesc}

\begin{methoddesc}[ConfigManager]{get}{option}
retrieve the value of \var{option}, returning \keyword{None} if \var{option} doesn't exist.
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{__getitem__}{key}
  retrieve the value of an option, raising a \exception{KeyError} if the option
  does not exist. This method allows you to use Python's dictionary syntax on a
  section as shown below.
\begin{verbatim}
# Print the value of the 'optionname' option
print(mysection['optionname'])
\end{verbatim}

  \note{Interpolation is performed when the value is retrieved with
    \method{__getitem__} or \method{get}. In particular, changing a
    configuration option during runtime can modify the values of other options
    if interpolation is used.}
\end{methoddesc}

\begin{memberdesc}[ConfigSection]{parent}
a reference to the parent \class{ConfigManager} object.
\end{memberdesc}

\begin{methoddesc}[ConfigSection]{__setitem__}{key, value}
create a new option or set an existing option with the name \var{key} and
the value of \var{value}.  This method allows you to use Python's 
dictionary syntax to set options as shown below.
\begin{verbatim}
# Create a new option called 'optionname'
mysection['optionname'] = IntegerOption("Test", --option="--test", default=0)
mysection['optionname'] = 10
\end{verbatim}
\end{methoddesc}

\subsection{Configuration Option Types}

\begin{classdesc}{Option[T]}{description, options, default}
  This class represents an option whose value has a ``simple'' type.
  Specifically, we require \code{T(s)} to correctly converts a string \var{s}
  to an object of type \class{T}. The type is determined at runtime based on
  the type of the default value. More complex options should inherit this class.

  From the point of view of the external API, every option item is expected to
  inherit \class{Option}, and is expected to implement the methods described
  below correctly. Moreover, the instance attribute \member{value} is expected
  to hold the value of the option.

  On the other hand, custom \method{__init__} implementations are not required
  to set the other instance attributes described below.
\end{classdesc}

\begin{memberdesc}[Option]{description}
  description of this option to be used in the \code{plastex --help} output.
\end{memberdesc}

\begin{memberdesc}[Option]{options}
  space separated list of command line argument that correspond to this option.
  The behaviour of this variable may be customized by implementations of
  \class{Option}.
\end{memberdesc}

\begin{memberdesc}[Option]{name}
  the key used by \var{argparse} to store the value read from the command line.
  Note that \var{argparse} does not group the argument values by section, so
  one has to be careful to avoid collision.

  This is set to the first entry in \member{self.option} with leading \code{-}s
  stripped.
\end{memberdesc}

\begin{memberdesc}[Option]{value}
  the actual value of the option
\end{memberdesc}

\begin{methoddesc}[Option]{registerArgparse}{group}
  this function should add the command line arguments for this configuration to
  the \var{argparse._ArgumentGroup} object \var{group}.
\end{methoddesc}

\begin{methoddesc}[Option]{updateFromDict}{data}
  sets the value of the option based on the data in \var{data}. The format of
  \var{data} is defined to be what is returned by
  \code{vars(parser.parse_args())}, where \var{parser} is populated by
  \method{registerArgparse}. This is intended to be used in conjuction with
  \method{registerArgparse}.
\end{methoddesc}

\begin{classdesc}{BooleanOption}{\optional{\class{Option} arguments}}
Boolean options are simply options that allow you to specify an `on' or 
`off' state. In a config file, the value is converted to a boolean via the
builtin \code{bool} function. Boolean options on the command-line do not take
an argument; simply specifying the option sets the state to true.

One interesting feature of boolean options is in specifying the command-line
options.  Since you cannot specify a value on the command-line (the existence
of the option indicates the state), there must be a way to set the state to
false.  This is done using the `not' operator (!).  When specifying the 
\var{options} argument of the constructor, if you prefix an command-line 
option with an exclamation point, the existence of that option indicates
a false state rather than a true state.  Below is an example of an \var{options}
value that has a way to turn debugging information on (\longprogramopt{debug}) 
or off (\longprogramopt{no-debug}).
\begin{verbatim}
BooleanOption("", options = '--debug !--no-debug', default=True)
\end{verbatim}
\end{classdesc}

\begin{classdesc}{FloatOption}{\optional{\class{Option} arguments}}
A \class{FloatOption} is an option that accepts a floating point number.
\end{classdesc}

\begin{classdesc}{IntegerOption}{\optional{\class{Option} arguments}}
An \class{IntegerOption} is an option that accepts an integer value.
\end{classdesc}

\begin{classdesc}{StringOption}{\optional{\class{Option} arguments}}
A \class{StringOption} is an option that accepts an arbitrary string.
\end{classdesc}

\begin{classdesc}{MultiStringOption}{\optional{\class{Option} arguments}}
A \class{MultiStringOption} is an option that is intended to be used multiple
times on the command-line, or take a list of values. Other options when
specified more than once simply overwrite the previous value.
\class{MultiStringOption}s will append the new values to a list.

In the configuration file, this is a space separated list, interpreted in the
same ways as shell arguments (with the same escaping/quoting rules for strings
that contains whitespaces). In fact, it is processed by \code{shlex.split}.

The individual values of \class{MultiStringOption} are strings. This can, of
course, be made generic, but such a use case has not arisen.
\end{classdesc}

\begin{classdesc}{DictOption[T]}{\optional{\class{Option} arguments}}
  This is an abstract base class for options whose value is a
  \code{Dict[str, T]}. This receives special treatment by
  \method{ConfigManager.read} --- if an unknown option is encounted in the
  configuration file, it looks for the first \class{DictOption} in the section
  and adds the \code{key, value} pair to the \class{DictOption}. It is an error
  to set the value of this option directly in a config file.

  There is no implementor in \code{ConfigManager.py}, but is used by
  \var{CountersOption}, \var{LinksOption} and \var{LogOption} in
  \code{Config.py}.

  Note that all implementors of \class{DictOption} must also implement
  \method{registerArgparse} (and can optionally implement other methods of
  \class{Option}).
\end{classdesc}

\begin{methoddesc}[DictOption]{entryFromString}{entry}
  a class method to convert a string to the desired value entry. This is used
  by the in the default implementation of \method{set}.
\end{methoddesc}

\begin{methoddesc}[DictOption]{set}{key, value}
  sets the value of the dict. The \var{value} is assumed to be a string.
\end{methoddesc}
